### 출처
***
[생활코딩](https://opentutorials.org/module/4134)

### 관계형 데이터 모델링

관계형 데이터 베이스를 공부하다 보면 "모델링"이라는 용어가 자주 등장합니다.

모델이란 무엇일까요? 조금 추상적이지만
"어떤 목적을 가지고 진짜를 모방하는 것"
즉, 좋은 모델이란 목적에 부합하는 모방 아닐까 라고 생각해보겠습니다.

우리의 목적은 컴퓨터, 
좀 더 정확하게는 관계형 데이터베이스,
더 구체적으로는 표에 정보를 담는 것입니다.

일단 정보를 데이터베이스에 저장하는 데 성공만 하면
컴퓨터의 연산 능력을 통해 인간의 능력을 뛰어넘는
거대한 양의 데이터를 엄청난 속도로 다룰 수 있게 됩니다.

문제는 현실 세계를 모방하여 정보로 만들고 표에 담아내는 것이 매우 어렵다라는 점입니다.

과거에는 이런 작업이 소수의 사람들만의 전유물이었지만,
일군의 전문가들이 천재나 전문가가 아니더라도 현실을 컴퓨터에 담을 수 있는 혁신적인 방법론을 만들었습니다.
그것이 바로 데이터 모델링입니다.

데이터 모델링이란 공부하기에 너무 어렵고 부담스러운 존재가 아니라 현실 세계의 복잡한 정보를 컴퓨터로 이사시켜줄 수 있는 아주 고마운 이삿짐 센터 정도로 생각하며 위대한 자신감을 가질 수 있습니다.

감사합니다 !! 데이터 모델링.

### 전체 흐름

데이터 모델링이 진행되는 일반적인 순서를 알아보겠습니다.
순서는 다음과 같습니다.

1. 업무파악
	- 진행해야할 업무에 대해 고객과 협력하여 파악합니다. 고객이 원하는 내용을 기획서를 통해 산출받습니다.
2. 개념적 데이터 모델링
	- 산출받은 업무 내용을 개념화 시켜 각각 어떻게 상호작용하는지 심사숙고 하는 시간을 가지고 정리하여 다이어그램을 산출합니다.
3. 논리적 데이터 모델링
	- 다이어그램을 초석으로 정리된 개념들을 관계형 데이터베이스의 패러다임과 일치하게끔 구성하여 표로 전환합니다.
4. 물리적 데이터 모델링
	- 사용하기에 적합한 데이터베이스 제품을 선택하고
    그것에 최적화된 쿼리를 작성해서 실제 표를 구현합니다.
    
정리하면 __데이터 모델링이란 문제를 현실로부터 가져와서 고도의 추상화 과정을 거쳐 컴퓨터라는 새로운 현실로 옮기는 작업입니다.__

이 두 개의 세계는 서로 다르기 때문에 데이터베이스의 표에 잘 담겨있는지 끊임없이 해나가야 할 필요가 있습니다.

### 업무 파악의 중요성
제대로 된 테이블을 만들기 위해서 업무 파악부터 알아보도록 하겠습니다.
업무 파악이란 정말 중요합니다.
현실 세계의 문제를 해결하고자 한다면 컴퓨터를 잘 이해하는 것만으로는 부족하고,
컴퓨터라는 강력하고 안 똑똑한 기계에게 현실 세계의 문제를 설명할 수 있을 정도로 업무를 이해해야 원하는 컴퓨터 프로그램을 만들 수 있기 때문입니다.

그러기 위해서 실무자들과 정확하게 소통하는 것이 중요합니다. 일이 익숙해서 잘하는 실무자가 아니라, 소통을 위해 설명까지 해야 하려면 업무를 정확하게 이해하는 실무자로 성장해야할 필요가 있습니다.

좋은 엔지니어로 성장하려면 공부와 인간관계를 외면할 수 없는 이유이기도 합니다.

소통을 위한 방법으로 UI를 그려보는 것이 많이 도움됩니다. 
의뢰한 사람과 함께 원하는 애플리케이션을 그려보는 시간을 가지는 것을 통해 원하는 것을 분명히 알 수 있습니다.

말의 기능에만 의존하는 것보다 서로 생각하는 것을 일치시키는 것에 굉장히 좋습니다.

### 업무파악. 기획
[ovenapp](https://ovenapp.io/)을 통해 기획서를 작성해 보겠습니다.

간단한 지식전달을 목적으로 하며, "글작성", "저자참여" 클릭시 페이지가 이동합니다.

#### 글읽기
![글읽기](https://user-images.githubusercontent.com/79819812/151706666-dfddda1e-6b58-4440-8ea4-3f77399ca8dc.png)

#### 글작성
![글저장](https://user-images.githubusercontent.com/79819812/151701998-b3856475-e7a8-411e-a70f-285c76783dfb.png)

#### 저자참여
![저자참여](https://user-images.githubusercontent.com/79819812/151702158-07e97253-ff7b-4531-939c-39f152debc7f.png)

### 개념적 데이터 모델링

개념적 데이터 모델링이 우리에게 제공하는 것은 다음과 같습니다.

- 현실에서 개념을 추출하는 일종의 필터 제공
- 개념에 대해 다른 사람들과 대화하게 되는 도구로써 작용

현실은 믿을 수 없을 정도로 복잡합니다.
작은 세포에서도 무한히 많은 일이 일어나는 현실 세계에서
개념을 추출하는 것은 무척 어렵습니다.

이러한 목적을 이루게 해주는 좋은 도구가 있습니다.
ERD(Entity Relationship Diagram)
다이어그램은 현실을 바라볼 수 있도록 다음과 같이 도와줍니다.

- 정보를 발견하고 표현
- 서로 연관된 정보를 그룹핑하여 인식하고 표현
- 정보 그룹 사이 관계를 인식하고 표현

이러한 장점들과 정교한 규칙들이 수십년간 적립되었기 때문에 아주 쉽게 표로 전환할 수 있습니다.


### 관계형 데이터베이스 개념의 구조

개념을 관계형 데이터베이스의 패러다임과 일치시키리면
다음과 같은 특성을 알고 있어야 합니다.

- RDB는 내포관계를 허용하지 않습니다.
- 거대 단일 테이블로 표현하면 중복이 발생합니다.

따라서 주제별로 테이블을 세분화할 필요가 있습니다.
이렇게 하면 데이터를 주제별로 그룹핑할 수 있고,
상황에 따라 JOIN을 사용하여 필요한 만큼 데이터를 합성할 수도 있습니다.

### ERD 구성요소

저자의 "소개","작성자명", "가입일"은 저자의 속성(Attribute)입니다. 
그리고 "소개","작성자명", "가입일"이라는 데이터들은 "저자"라는 공통된 특징을 포함합니다. 객체지향의 추상화와 비슷하다고 생각합니다.
또 저자와 글은 "쓰다", 글과 댓글은 "소속"이라는 관계에 종속되어 있습니다.

이런 개념들은 다음과 같이 정리할 수 있습니다.

- 저자 -> Entity
- "소개","작성자명", "가입일" -> Attribute
- "쓰다", "소속" -> Relationship

이러한 ERD의 구성요소들은 후에 다음과 같이 변합니다.

- Entity : Table
- Attribute : Column (Row는 Tuple입니다)
- Relationship : PK, FK

개념에 집중한 개념적 데이터 모델링은 실제 데이터베이스 제품들과 조금 다르지만 밀접한 관계입니다.

### 엔티티, 속성

기획서를 살펴보면 저자, 글, 댓글이 entity인 것을 알 수 있습니다. [draw.io](https://app.diagrams.net/)에서 erd를 구현해보겠습니다.

#### entity

![entity](https://user-images.githubusercontent.com/79819812/151705169-7d3ed530-485f-490e-8dd9-5105d31b26c4.png)

각 entity가 포함하는 속성도 표현해보겠습니다.

#### attribute
![attribute](https://user-images.githubusercontent.com/79819812/151705533-5969be09-0f3c-4832-94bc-9d6bae172cd5.png)

### 식별자 지정

국가가 주민번호로 국민을 식별하듯이 원하는 대상을 정확히 지정하기 위해 고유한 식별자가 필요합니다. 훗날 기본키가 될 식별자를 알아보겠습니다.

- candidate key : 테이블에서 고유한 column을 식별자로 지정하려면 값이 중복되지 않도록 해야 합니다. 이것에 적합한 키들을 "후보키"라고 합니다.
- primary key : 후보키 중에서 선택한 식별자를 "기본키"라고 합니다.
- alternate key : 후보키에서 기본키가 아닌 것들을 "대체키"라고 합니다.
- composite key : 두 가지를 합쳐서 식별해야 할 경우에 선택하여 지정하는 식별자를 "중복키" 라고 합니다.

식별자를 erd로 표현해보겠습니다.

![identifier](https://user-images.githubusercontent.com/79819812/151706337-e3c56ef8-7c0e-4857-9678-a8d4e40306cc.png)

### 엔티티 연결

관계형 데이터베이스의 관계 형성은 PK와 FK가 연결되는 걸 통해서 구협됩니다.

- foreign key : 참조를 통해 다른 테이블의 식별자를 연결해주는 역할

FK를 erd로 표현해보겠습니다.

![relationship](https://user-images.githubusercontent.com/79819812/151708728-9c980328-d4c8-42a1-afa7-cf44e92bead8.png)

### Cardinality, Optionality

#### Cardinality
Cardinality는 두 데이터베이스 테이블에 있는 데이터 간의 관계를 나타냅니다. 
한 엔터티의 인스턴스가 다른 엔터티의 인스턴스와 관련된 수를 정의합니다.
한 번 데이터베이스의 관계성을 알아보겠습니다.

저자와 id의 관계를 살펴보겠습니다.
저자는 하나의 id만 가집니다.
마찬가지로 id에게 저자는 하나입니다.
이러한 관계를 __1:1__ 이라고 표현합니다.

이번엔 저자와 글입니다.
저자는 여러 글을 작성할 수 있습니다.
하지만 각 글들은 하나의 저자만 존재합니다.
이러한 관계를 __1:N__, 또는 __1대다__ 라고 표현합니다.
(다대다 관계는 실제로 적용하기 어렵기 때문에 연결 테이블을 통해 1대다 관계로 적용됩니다.)

만약 하나의 글을 여러 명이 수정할 수 있는 시스템이라고 가정한다면, 각 글 또한 여러 저자가 존재할 수 있습니다.
이러한 관계는 __N:M__, 또는 __다대다__ 라고 표현합니다.

#### Optionality

저자는 댓글을 작성해야만 하지 않습니다.
댓글을 작성하지 않을 수도 있습니다.
따라서 저자에게 댓글은 "옵션"입니다.
이러한 선택성의 특성을 가진 관계를 optionality라고 합니다.

반대로 댓글이 작성되었다면 저자가 반드시 존재해야 합니다.
댓글에게 저자는 필수입니다.
이것을 Mandatory라고 합니다.

저자와 댓글은 필수, 선택이라는 관계이지만
동시에 일대일, 일대다, 다대다 등이 포함되는 cardinality도 포함되어 있습니다.

이 두 가지 특성을 모두 포함하여 다이어그램에 표현해보겠습니다.

#### ERD 완성
![erd](https://user-images.githubusercontent.com/79819812/151710469-16d9df5d-8e20-4606-a7d6-997b67d0dabc.png)


### 논리적 데이터 모델링

개념적 모델링이 업무에서 개념을 뽑아내는 일이라면
뽑아낸 개념을 논리적 데이터 모델링은 관계형 데이터베이스 패러다임과 일치하도록 데이터 형식을 잘 정리정돈 하는 것입니다. 최대한 이상적인 모습으로 잘 정리정돈 해보겠습니다.

- Mapping Rule : 다이어그램을 통해 표현한 내용을 관계형 데이터베이스에 맞는 형식으로 전환하는 방법론

Mapping Rule을 통해 다음과 같이 전환해보도록 하겠습니다.

- Entity -> Table
- Attribute -> Column 
- Relationship -> PK, FK

#### 테이블과 컬럼 생성


가장 먼저 엔티티를 테이블로 바꿔보겠습니다.

![entityTable](https://user-images.githubusercontent.com/79819812/151714760-b15a4624-4d96-4bfe-9529-fbdb79bada3d.png)

#### 1:1
관계형 데이터베이스 모델에 맞게 PK와 FK 연결하는 것을 통해 1:1 관계를 처리해보겠습니다.

가장 단순한 1:1 관계부터 시작하고 싶어서 기획서에 휴면자 entity를 추가했습니다.

![document1:1](https://user-images.githubusercontent.com/79819812/151714931-3791748b-7c7b-4116-a709-639109e4d8f8.png)

저자가 휴면 상태가 되면 관리하는 테이블을 추가하겠습니다.
저자는 휴면하지 않을 수 있으므로 선택성,
휴면자가 있다면 반드시 저자는 존재하므로 필수성이 있는 관계입니다.

휴면 id를 PK값을 하기 전에 잘 생각해보면,
그럴 필요없이 저자 id와 같은 값을 주면 됩니다. 
동시에 휴면자 테이블은 cardinality이기 때문에 저자 테이블을 의존하고 있는 걸 알 수 있습니다.

따라서 저자 테이블에 primary key를,
휴면자 테이블에 foreign key를 설치하는 것이 적합합니다.
저자 테이블을 참조하는 휴면자 테이블에 의해 두 테이블의 관계가 생성됩니다.
저자1(optionality) : 휴면자1(cardinality)

![documentFK](https://user-images.githubusercontent.com/79819812/151715348-0e7795fb-89a5-42a3-ac80-f05cdcbe75bf.png)


![table](https://user-images.githubusercontent.com/79819812/151715690-321907b0-aeed-404b-bc08-a180c3c32d22.png)


#### 1:N

![erd](https://user-images.githubusercontent.com/79819812/151710469-16d9df5d-8e20-4606-a7d6-997b67d0dabc.png)

댓글은 저자와도 관계를 가지고 있고, 글과도 관계를 가지고 있습니다.
댓글이 생성되려면 저자id와 본문id가 필요합니다.

![tableComment](https://user-images.githubusercontent.com/79819812/151715958-f975787b-1650-4171-be20-3ea9ad9c5401.png)

이것을 관계형 데이터 모델에 반영해보겠습니다.
![1NRDB](https://user-images.githubusercontent.com/79819812/151716036-06b949ad-a7f2-4458-8f9f-de3a74474993.png)

PK를 가지고 있는 author와 topic을 참조하여
comment 테이블에서 2개의 FK를 가지게 되었습니다.

author와 topic에게 commnet는 옵션,
commnet에게 author와 topic은 필수입니다.

#### N:M

저자와 글은 N:M 관계입니다.
1명의 저자가 여러개의 글을 쓸 수 있고 하나의 글을 여러 저자가 작성할 수도 있습니다.

예시를 들어보겠습니다.
저자 : kim, lee
글 : MySQL, hibernate, ORACLE


![NMexam](https://user-images.githubusercontent.com/79819812/151718881-c40d5a76-149f-4dfe-8d8f-e80d3df77267.png)

kim과 lee가 작성한 글들을 살펴보면 중복된 부분이 있습니다.
topic에 author_id 데이터가 들어갈 때 다수의 데이터가 들어갑니다.
author에 topic_id 데이터가 들어갈 때도 마찬가지입니다.
이런 유형의 데이터는 JOIN 할 수 없습니다.
다수 데이터에 포함되는 특정 데이터만 조회하거나 정렬할 때 문제가 발생할 것 같아 보입니다.

N:M 관계는 그 자체만으로는 모델링하기가 애매합니다.
그래서 이 두 테이블을 연결해줄 중재자가 필요합니다.
"mapping"이라는 연결 테이블을 생성했습니다.

이 테이블에 author_id와 topic_id column을 따로 생성하여 각각의 데이터도 담겨있고 JOIN도 할 수 있도록 문제를 해결했습니다. 연결 테이블을 작성하면 추가적인 정보도 담을 수도 있습니다.
예를 들어 각각의 저자가 언제 글을 수정했는지 같은 원하는 정보를 column을 추가하여 확인할 수도 있습니다.

scheme로 표현하면 다음과 같습니다.

![NMScheme](https://user-images.githubusercontent.com/79819812/151719293-62dc1525-2e81-434e-a697-86b2b004f9c6.png)

※ 정정 : write (1..N) ---- (1) topic


### 정규화 (Normalization)

정규화 : 정제되지 않은 데이터를 관계형 데이터베이스에 어울리는 표로 만들어주는 방법


다음 topic 테이블은 title과 type 두 개의 컬럼을 동시에 중복키, 기본키로 지정했습니다.
각 행들은 두 개의 컬럼을 통해 식별됩니다.

색을 표시한 데이터는 하나의 컬럼에 다수 데이터가 있거나 중복된 데이터가 있습니다.

전혀 정제되어 있지 않은 데이터들을 UNF부터 3NF까지 순서대로 정규화해보겠습니다.

![UNF](https://user-images.githubusercontent.com/79819812/151719580-7e22261a-95b9-4978-977a-d1e5e30c925a.png)

#### Fisrt Normal Form - Atomic columns

각 테이블을 최소한으로 쪼개서 정규화해보겠습니다.

tag 컬럼을 보면 각 행마다 두 개의 값을 가지고 있습니다.


```
select * from topic where tag = 'free'
select * from topic order by tag
```

free라는 값이 들어있는 컬럼의 행을 알고싶다거나
tag 컬럼을 정렬하고 싶을 때 그러지 못하는 상황이 생길 수 있습니다. 또는 다른 테이블과 JOIN 할 때에도 어렵거나 불가능할 것입니다.
각 컬럼의 값이 복수 이상이라면 여러 문제를 가질 수 있기때문에 정규화가 필요합니다.

topic과 tag를 쪼개어서 각각 테이블로 나누어보면,
서로 여러 데이터를 가질 수 있기 때문에 N:M입니다.

- tag 컬럼에 있던 데이터를 쪼개어서 tag_id컬럼이 있는 연결테이블을 생성해서 해결할 수 있습니다.  
- topic_title을 기본키로 선택하고 tag_id컬럼의 행을 추가하면 다수의 데이터를 나누어 입력할 수 있습니다.
- 동시에 topic_tag_relation 테이블은 topic에 의존합니다.

![1nf](https://user-images.githubusercontent.com/79819812/151720517-a18dc3a6-c8a0-4bc9-b547-a5fa8028b314.png)

#### Second Normal Form - No partial dependencies

topic 테이블을 살펴보면 많은 중복이 발생하고 있습니다. 이것은 부분 종속성 때문입니다.

중복되는 데이터들은 type에 상관없이 title 컬럼에만 의존하고 있습니다.

topic과 type, 그리고 topic과 type 모두에게 의존하던 price도 분리 분리하여 테이블로 생성하면 topic에서 중복되는 행들을 제거할 수 있습니다.

부분 종속성 제거를 통해 두번째 정규화도 해결되었습니다.


새로 생성한 topic_type 테이블을 연결 테이블로써 활용하고 이전에 정규화했던 테이블까지 호출하면

- 한 행에 다수의 데이터가 있지도 않고,
- 중복되는 행 없는 정규화가 가능합니다.

![2nf](https://user-images.githubusercontent.com/79819812/151721018-dbe433ce-a1e4-47aa-82ca-4777c30d665b.png)

#### Third Normal Form - No transitive dependencies
title은 기본키입니다. 따라서 title의 행은 기본키에 종속되어 있고 행 전체를 대표합니다.

author_id는 역시 기본키의 행에 의존합니다.
하지만 author_name, author_profile은 author_id에 의존하고 있습니다.
이런 관계를 이행적 종속성이라고 합니다.

이행적 종속성은 중복을 유발하고 실제로 author_id에 의존하는 데이터들은 중복되고 있습니다.

title에 의존하는 데이터와 author에 의존하는 데이터를 분리하면 author 테이블의 중복은 제거됩니다.

- topic의 author_id는 중복되지만 FK는 중복이라고 하지 않습니다.

성격이 비슷해보이는 컬럼들은 내부적으로 자신의
이중적 종속일 확률이 높습니다.

![](https://images.velog.io/images/urtimeislimited/post/29630f74-81b5-4d34-a0cd-35ea361de68e/image.png)


### 물리적 데이터 모델링

논리적 데이터 모델링이 관계형 데이터베이스 패러다임에 잘 맞는 이상적인 표를 만드는 것이었다면, 물리적 데이터 모델링은 선택한 데이터베이스 제품에 만는 현실적인 고려는 하는 방법론입니다. 
이 단계에서 가장 중요한 것은 "성능"입니다. 

여러 가지 수단을 강구 했음에도 불구하고 성능 향상에 어려움이 있다면 표의 구조를 바꾸는 역정규화를 시도합니다. 역정규화는 혹독한 대가를 치러야 하기 때문에, 이러한 대가를 지불할만한 것인지는 처한 상황에 의해서 결정됩니다.

#### 역정규화(denormalization)

- 역정규화 : 정규화를 통해 만든 이상적인 표를 성능이나 또는 개발의 편의성을 위해 구조를 바꾸는 것

![denormalization ](https://docs.google.com/spreadsheets/d/1xlf6acYUziX9KgK9gOfLhdHtVWxSzIviVvIyhdwYeII/edit#gid=2096807931)





